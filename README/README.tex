\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Automated Reasoning}
\author{
    Brian Kuhns,
    Thomas Johnson,
    Graham Northup,
    Josh Gordon
  } % please add the other names and corect any mis spellings
\date{April 2019}

\begin{document}

\maketitle

\section{Introduction}

The algorithm is an extension of ordered resolution,
which attempts to find finite representations of infinite clause families,
and proceed with ordered resolution on these families.

\section{Anatomy of a Scheme}

A scheme has 2 parts:
a list of implications and a list of base clauses.

Each implication is a list of clauses and a clause.
Signifying that the and of all of left clauses implies the right clause,
hereafter the hypotheses and the conclusion.

An implication is syntactically valid if each hypothesis subsumes the conclusion.
A scheme is syntactically valid if each implication is valid and
each hypothesis of each implication subsumes each base clause.

These properties are important because they ensure that any implication can be applied to any set of clauses in the scheme.
Without these properties resolution and subsumption become much more complex, and may be undecidable.

A scheme is said to contain a clause iff it can be derived by applying some finite sequence of the 
implications to the base clauses.

\section{Learning Implications}

Learning implications is done in two phases: finding candidates and constructing implications from them.
 
\subsection{Candidates}

A candidate is a tree whose nodes are clauses and whose leafs are clauses.
Suppositions are also clauses but they are handled differently to construct implications.
  
A candidate should be derived whenever the history of a clause contains a subtree which subsumes it.
A clause-tree subsumes another clause-tree
  if the graphs are isomorphic the and each node subsumes the corresponding node in the other tree.

Two clauses are of the same form if some clause subsumes both of them.

The important property to have is that,
if any set of clauses of some form can derive a new clause of one of that forms.
A scheme is derived which subsumes all such resolutions.

\subsection{Implications}

When given a candidate the important property to ensure is that if it can be resolved indefinitely,
then a scheme which subsumes all of these clauses is derived.

First mark all leaf clauses of the same form as the conclusion as suppositions.

The following properties should be vetted.
\begin{itemize}
  \item There is at least one supposition
  \item The conclusion can larger than all of the hypothesis
  \item The conclusion can be a non-tautology
  \item The conclusion has at least as many predicates as the hypotheses
\end{itemize}

Once these properties are verified find the most specific form of the suppositions and conclusion.

This can be found by a process much like unification except when two clauses are not unifiable instead 
  of failing replace them with a variable.

Next resolve clauses in the tree, with all the suppositions replaced by the most specific form.
The resulting clauses are the conclusions and the suppositions are the implications.


\section{Subsumption}

\subsection{Clause to Scheme}
  
  A clause should subsume an implication if all but finitely many things which it can derive are subsumed by the clause.
  In order to check this if the conclusion and the 
  A clause subsumes an implication if it subsumes the conclusion.
  Clause to Scheme is not necessary if the implications can be subsumed and the schemes are rebuilt each round.
 
\subsection{Scheme to Clause}
A scheme subsumes a clause if it contains any clauses which subsume that clause.
To determine this: 
  First check if the target is a base clause.
  For any conclusion of an implication which subsumes the target
    apply the unifier of that subsumption to each of the hypotheses of the implication and treat these as the new targets
    if all of theme are subsumed this is successful.
  When doing this maintain a state of the list of previous targets on each recursive call and fail to find a target if it is in this list
  this should prevent some infinite loops without causing unnecessary failure.

\subsection{Scheme to Scheme}

A scheme subsumes a scheme if all clauses derived by the right scheme are subsumed by a clause derived by the left scheme
To determine this:
  This is equivalent to the right base clause being subsumed by the left scheme
  so this step can be skipped as long as the schemes are rebuilt every layer.

\section{Resolution}

\subsection{Scheme with Clause}

To resolve a scheme against a clause it is necessary to create a list of clauses and implications containing every
clause which could be derived by resolving any clause in the scheme with the clause. 

To determine this:
For each implication in the scheme if the conclusion resolves with the clause 
  the result of this resolution is the new conclusion
  to get the new hypotheses apply the unifier to each of the hypotheses
  also resolve the clause against each of the base clauses.

\subsection{Scheme with Scheme}


    To resolve a scheme against a scheme it is necessary to create a list of clauses and schemes containing every clause which could be derived by resolving any clause in one scheme with a clause in the other.
    In order to do this, for each pair of conclusions (one left one right) that resolve, find the new implications, and the new clauses.

\subsubsection{New implications}
  
  To find the new implications: For both schemes create a list of predicate-level functions corresponding to how each implication changes the predicate
  used in the resolution.
  The predicate-level functions should be stored with the clause-level function that causes that predicate-level change.

  Next begin a stateful recursive chase.
    The state is the previously encountered problems and the list of clause and predicate level functions have been applied.
    When you encounter a problem you've seen before create an implication
    from the original resolution to the resolution after applying all the clause level functions

\subsubsection{New Clauses}

          To find a generating base of resolutions unify each base clause of one schema with the other schema.
             This works because the hypotheses of each implication subsumes the conclusion so if there is a failure to unify nothing derived by it will unify either.
             If there is a successful unification then the search can stop because any further unifications would be absorbed by the implications.

\section{Finding Empty Clauses}
  As no implication decreases the number of literals in a clause schema only conatin the empty clause if it is a base clause.
  Thus it is sufficent to check clauses for the empty clause.

\section{Tautology Removal}
  I don't know a way to ensure tautology removal in schema.
  I don't think it is nesecary for corectness.
  



\end{document}
