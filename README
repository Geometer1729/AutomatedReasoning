The current plan is Clause level Schematization

When a Clause history has a cycle ie. 

D 7
  G 1
  D 6
    G 2
    D 5
      G 1
      D 4
        G 2
        G 0

The cycle has a base (G 0) and a chain [ G 1 , G 2 ] and a result (D 5) 
D 5 because it is the result of one application

Or when ever a clause is resolved proceed twice with each clause as a base and the other clause as the sole element of a length one chain.

Attempt to find the most specific clause which subsumes both the base and the result ie.
P(a) or P(b) , P(f(a)) or P(b)

Should produce P(x) or P(b)

This should proceed like unification but when two clauses are not unifiable replace them with a variable

Next the MSMS (Most Specific Mutually Subsumptive clause) should then be resolved against each clause in the chain in order.
This should return a list of all possible resolution outcomes
  of this list the following criteria should be filtered before implications are formed
    clauses must be subsumed by the base 
      ones which are not subsumed by the base would not be in danger of looping 
    clauses must produce at least one predicate which can be larger than the base
      if the clause predicts strictly smaller literals than there is not danger of looping 
    It must be possible for the output to not be a tautology
      if it only produces tautologies then the implication isn't necessary
Clauses with these properties should be turned into implications stored as the two clauses

Once an implications are derived
  for each clause create a list of all the implications where the base subsumes the clause

A scheme is a list of implications and a clause

Once the schemes are created ordered resolution must proceed with each scheme doing everything that the infinite set of clauses would do.

Subsumption
  Scheme -> Clause
    a scheme subsumes a clause if it contains any clauses which subsume that clause
      To do this:
          for any conclusion of an implication which subsume the target
            apply the unifier of that Subsumption to the base of the hypothesis of the implication and treat this as the new target
            when doing this maintain a state of the list of previous targets on each recursive call and fail to find a target if it is in this list
            this should prevent some infinite loops without causing unnecessary failure
  Scheme -> Scheme
    a scheme subsumes a scheme if all clauses derived by the right scheme are subsumed by a clause derived by the left scheme
    To do this:
      This is equivalent to the right base clause being subsumed by the left scheme
      so this step can be skipped as long as the schemes are rebuilt every step

    

Resolution
  Schemes must be resolved against all clauses and schemes
  Scheme -> Clause
    To resolve a scheme against a clause it is necessary to create a list of clauses and schemes containing every clause which could be derived by resolving any clause in the scheme with the clause. 
      To do this:
        For each conclusion of an implication which unifies with the target
          apply the unifier to the hypothesis of the implication and treat this as the new target
          similarly to subsumption this should be done with state of a  list of previous targets and fail any recurring targets
        Attempt to unify 
  Scheme -> Scheme
    To resolve a scheme against a scheme it is necessary to create a list of clauses and schemes containing every clause which could be derived by resolving any clause in one scheme with a clause in the other.
    To do this:
      For each pair of conclusions (one left one right)
        attempt to resolve them
        if they resolve
          find a generating list of equivalent paths of implications between the two schema
            do this by a recursive stateful chase
              the state is the previously encountered problems and the order in which implications have been applied 
              once you encounter a problem you've seen before just compose the implications
          find a generating base of resolutions
            To do this unify each base of one schema with the other 
             This works because the hypothosis of each implication subsumes the conclusion so if there is a faliure to unify nothing derived by it will unify either
             If there is a succesfull unification then the search can stop because any further unificatins would be absorbed by the implications

Consistency checking
  A scheme can't contain the empty clause unless it's argument was the empty clause
  so it is sufficient to check clauses and not schemes for containing the empty clause
  
Tautology Removal
  tautology removal is not necessary for correctness so it is sufficient to only remove tautologies from clauses 
    However if an implication always produces a tautology it can be removed 

  
  
